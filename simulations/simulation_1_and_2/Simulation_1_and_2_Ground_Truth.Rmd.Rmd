---
title: "Simulation 1 Ground Truth"
output: html_document
date: "2024-03-25"
---

Load relevant libraries

```{r}
library(pracma)
library(Rdimtools)
library(Matrix)
```

Code for method

```{r}
est_Vx_Vs <- function(X1, X2, d1, d2) {
  OUT <- list()
  
  p <- ncol(X1)
  
  Cx1 <- cov(X1)
  Cx2 <- cov(X2)
  
  OUT$V1 <- eigen(Cx1)$vectors[,1:d1]
  OUT$V2 <- eigen(Cx2)$vectors[,1:d2]
  
  return(OUT)
}

sigma1_test_stat = function(X1, X2, d1, d2) {
  
  OUT <- est_Vx_Vs(X1, X2, d1, d2)
  
  U = OUT$V1
  V = OUT$V2
  
  M <- t(U) %*% V
  SVD <- svd(M)
  cosines <- SVD$d
  # To prevent any numerical precision issues from creating values outside the interval [-1,1]
  cosines <- pmin(1, pmax(-1, cosines))
  return(rev(cosines)[1])
  
}

sing_vals <- function(U, V) {
  M <- t(U) %*% V
  SVD <- svd(M)
  cosines <- SVD$d
  # To prevent any numerical precision issues from creating values outside the interval [-1,1]
  cosines <- pmin(1, pmax(-1, cosines))
  return(cosines)
}

boot_test = function(X1, X2, d1, d2, B) {
  
  X1 <- scale(X1, center = T, scale = F)
  X2 <- scale(X2, center = T, scale = F)
  
  test_stat = sigma1_test_stat(X1, X2, d1, d2)
  n1 = nrow(X1)
  n2 = nrow(X2)
  
  boot_stats = vector()
  
  for (j in 1:B) {
    
    #print(j)
    
    X1t <- X1[sample(1:n1, size = n1, replace = T),]
    X2t <- rbind(X1, X2)[sample(1:(n1+n2), size = n2, replace = T),]
    boot_stats[j] = sigma1_test_stat(X1t, X2t, d1, d2)
    
  }
  
  p_value <- mean(boot_stats < test_stat)
  
  return(list(test_stat = test_stat, p_value = p_value, boot_stats = boot_stats))
  
}

CD = function(X1, X2, d1, d2, epsilon, B) {
  
  p <- ncol(X1)
  
  sigma_x1 <- cov(X1)
  sigma_x2 <- cov(X2)
  
  OUT <- est_Vx_Vs(X1, X2, d1, d2)
  singular_vals <- rev(sing_vals(OUT$V1, OUT$V2))
  
  L <- list()
  L$CD <- sum(singular_vals < 1 - epsilon)
  
  test = boot_test(X1, X2, d1, d2, B)
  
  L$test_stat = test$test_stat
  L$p_value = test$p_value
  L$singular_vals <- singular_vals
  
  return(L)
  
}
```

Simulation 1. First generate data under the assumption that C(X1) c C(X2).

```{r}
generate_fake_data = function(p, n1, n2, d1, d2, sd1, sd2) {
  
  S2 <- qr.Q(qr(matrix(rnorm(n = p * d2), nrow = p)))
  S1 <- S2[, 1:d1]
  
  z1 <- matrix(rnorm(d1 * n1), nrow = d1)
  z2 <- matrix(rnorm(d2 * n2), nrow = d2)
  
  e1 <- matrix(rnorm(p * n1, sd = sd1), nrow = p)
  e2 <- matrix(rnorm(p * n2, sd = sd2), nrow = p)
  
  X1 <- t(S1 %*% z1 + e1)
  X2 <- t(S2 %*% z2 + e2)
  
  return(list(X1 = X1, X2 = X2))
  
}

set.seed(1)
d1 <- 6
d2 <- 8
sd1 <- 0.5
sd2 <- 0.5

CDs <- vector()
p_values <- vector()
sing_val1s <- vector()
sing_val2s <- vector()
sing_val3s <- vector()
sing_val4s <- vector()

for (i in 1:100) {
  
  L <- generate_fake_data(20, 100, 100, d1, d2, sd1, sd2)
  
  OUT <- CD(L$X1, L$X2, d1, d2, 0.1, 1000)
  
  CDs[i] <- OUT$CD
  p_values[i] <- OUT$p_value
  sing_val1s[i] <- OUT$singular_vals[1]
  sing_val2s[i] <- OUT$singular_vals[2]
  sing_val3s[i] <- OUT$singular_vals[3]
  sing_val4s[i] <- OUT$singular_vals[4]
  
}

mean(CDs)
sd(CDs)

mean(p_values)
sd(p_values)

mean(sing_val1s)
sd(sing_val1s)

mean(sing_val2s)
sd(sing_val2s)

mean(sing_val3s)
sd(sing_val3s)

mean(sing_val4s)
sd(sing_val4s)
```

(Simulation 2.) Next, under the assumption of unique directions in X1 orthogonal to C(X2).

```{r}
generate_fake_data_ortho = function(p, n1, n2, d1, d2, d12, sd1, sd2) {
  
  ovlp <- d1 - d12
  
  S2 <- qr.Q(qr(matrix(rnorm(n = p * (d1+d2)), nrow = p)))
  S1 <- S2[, 1:d1]
  S2 <- S2[, (d1-ovlp+1):(d1-ovlp+d2)]
  
  z1 <- matrix(rnorm(d1 * n1), nrow = d1)
  z2 <- matrix(rnorm(d2 * n2), nrow = d2)
  
  e1 <- matrix(rnorm(p * n1, sd = sd1), nrow = p)
  e2 <- matrix(rnorm(p * n2, sd = sd2), nrow = p)
  
  X1 <- t(S1 %*% z1 + e1)
  X2 <- t(S2 %*% z2 + e2)
  
  return(list(X1 = X1, X2 = X2))
  
}

set.seed(1)
d1 <- 6
d2 <- 8
d12 <- 6
sd1 <- 0.5
sd2 <- 0.5


CDs <- vector()
p_values <- vector()
sing_val1s <- vector()
sing_val2s <- vector()
sing_val3s <- vector()
sing_val4s <- vector()
sing_val5s <- vector()
sing_val6s <- vector()


for (i in 1:100) {
  
  print(i)
  
  L <- generate_fake_data_ortho(20, 100, 100, d1, d2, d12, sd1, sd2)
  
  OUT <- CD(L$X1, L$X2, d1, d2, 0.1, 1000)
  
  CDs[i] <- OUT$CD
  p_values[i] <- OUT$p_value
  sing_val1s[i] <- OUT$singular_vals[1]
  sing_val2s[i] <- OUT$singular_vals[2]
  sing_val3s[i] <- OUT$singular_vals[3]
  sing_val4s[i] <- OUT$singular_vals[4]
  sing_val5s[i] <- OUT$singular_vals[5]
  sing_val6s[i] <- OUT$singular_vals[6]
  
}

mean(CDs)
sd(CDs)

mean(p_values)
sd(p_values)

mean(sing_val1s)
sd(sing_val1s)

mean(sing_val2s)
sd(sing_val2s)

mean(sing_val3s)
sd(sing_val3s)

mean(sing_val4s)
sd(sing_val4s)

mean(sing_val5s)
sd(sing_val5s)

mean(sing_val6s)
sd(sing_val6s)

```


Validity/Conservativism plots. Simulation 1 of p-value (Hypothesis Test).

Setting 1

```{r}
set.seed(1)

iterations = 100
B = 1000
p_values = vector()

generate_fake_data = function(p, n1, n2, d1, d2, sd1, sd2) {
  
  S2 <- qr.Q(qr(matrix(rnorm(n = p * d2), nrow = p)))
  S1 <- S2[, 1:d1]
  
  z1 <- matrix(rnorm(d1 * n1), nrow = d1)
  z2 <- matrix(rnorm(d2 * n2), nrow = d2)
  
  e1 <- matrix(rnorm(p * n1, sd = sd1), nrow = p)
  e2 <- matrix(rnorm(p * n2, sd = sd2), nrow = p)
  
  X1 <- t(S1 %*% z1 + e1)
  X2 <- t(S2 %*% z2 + e2)
  
  return(list(X1, X2))
  
}

for (i in 1:iterations) {
  
  #print(i)
  
  n1 = 100
  n2 = 100
  d1 = 6
  d2 = 8
  
  original_data = generate_fake_data(20, 100, 100, 6, 8, 0.5, 0.5)
  X1 = original_data[[1]]
  X2 = original_data[[2]]
  true_stat = sigma1_test_stat(X1, X2, d1, d2)
  
  boot_stats = vector()
  
  for (j in 1:B) {
    
    X1t <- X1[sample(1:n1, size = n1, replace = T),]
    X2t <- rbind(X1, X2)[sample(1:(n1+n2), size = n2, replace = T),]
    boot_stats[j] = sigma1_test_stat(X1t, X2t, d1, d2)
    
  }
  
  p_values[i] <- sum(boot_stats < true_stat) / B
  
}

p_values

summary(p_values)

hist(p_values)

d = data.frame(alpha = seq(0, 1, 0.005),
               cumulatives = sapply(seq(0, 1, 0.005), function(x) sum(p_values < x)/iterations))

g1 <- ggplot(data = d) +
  geom_point(aes(x = alpha, y = cumulatives)) +
  labs(x = "alpha", y = "Observed Type I Error Rate",
       title = "") +
  geom_abline(intercept = 0, slope = 1) +
  theme_classic()
```

Setting 2

```{r}
set.seed(1)

iterations = 100
B = 1000
p_values = vector()

generate_fake_data = function(p, n1, n2, d1, d2, sd1, sd2) {
  
  S2 <- qr.Q(qr(matrix(rnorm(n = p * d2), nrow = p)))
  S1 <- S2[, 1:d1]
  
  z1 <- matrix(rnorm(d1 * n1), nrow = d1)
  z2 <- matrix(rnorm(d2 * n2), nrow = d2)
  
  e1 <- matrix(rnorm(p * n1, sd = sd1), nrow = p)
  e2 <- matrix(rnorm(p * n2, sd = sd2), nrow = p)
  
  X1 <- t(S1 %*% z1 + e1)
  X2 <- t(S2 %*% z2 + e2)
  
  return(list(X1, X2))
  
}

for (i in 1:iterations) {
  
  #print(i)
  
  n1 = 200
  n2 = 200
  d1 = 6
  d2 = 8
  
  original_data = generate_fake_data(20, 200, 200, 6, 8, 0.5, 0.5)
  X1 = original_data[[1]]
  X2 = original_data[[2]]
  true_stat = sigma1_test_stat(X1, X2, d1, d2)
  
  boot_stats = vector()
  
  for (j in 1:B) {
    
    X1t <- X1[sample(1:n1, size = n1, replace = T),]
    X2t <- rbind(X1, X2)[sample(1:(n1+n2), size = n2, replace = T),]
    boot_stats[j] = sigma1_test_stat(X1t, X2t, d1, d2)
    
  }
  
  p_values[i] <- sum(boot_stats < true_stat) / B
  
}

p_values

summary(p_values)

hist(p_values)

d = data.frame(alpha = seq(0, 1, 0.005),
               cumulatives = sapply(seq(0, 1, 0.005), function(x) sum(p_values < x)/iterations))

g2 <- ggplot(data = d) +
  geom_point(aes(x = alpha, y = cumulatives)) +
  labs(x = "alpha", y = "",
       title = "") +
  geom_abline(intercept = 0, slope = 1) +
  theme_classic()

library(gridExtra)
grid.arrange(g1, g2, ncol = 2)
```

