---
title: "Simulation 1 Ground Truth"
output: html_document
date: "2024-03-25"
---

Load relevant libraries

```{r}
library(pracma)
library(Rdimtools)
library(Matrix)
```

Code for method

```{r}
est_Vx_Vs <- function(X1, X2, d1, d2) {
  OUT <- list()
  
  p <- ncol(X1)
  
  Cx1 <- cov(X1)
  Cx2 <- cov(X2)
  
  OUT$V1 <- eigen(Cx1)$vectors[,1:d1]
  OUT$V2 <- eigen(Cx2)$vectors[,1:d2]
  
  return(OUT)
}

sigma1_test_stat = function(X1, X2, d1, d2) {
  
  OUT <- est_Vx_Vs(X1, X2, d1, d2)
  
  U = OUT$V1
  V = OUT$V2
  
  M <- t(U) %*% V
  SVD <- svd(M)
  cosines <- SVD$d
  # To prevent any numerical precision issues from creating values outside the interval [-1,1]
  cosines <- pmin(1, pmax(-1, cosines))
  return(rev(cosines)[1])
  
}

sing_vals <- function(U, V) {
  M <- t(U) %*% V
  SVD <- svd(M)
  cosines <- SVD$d
  # To prevent any numerical precision issues from creating values outside the interval [-1,1]
  cosines <- pmin(1, pmax(-1, cosines))
  return(cosines)
}

boot_test = function(X1, X2, d1, d2, B) {
  
  X1 <- scale(X1, center = T, scale = F)
  X2 <- scale(X2, center = T, scale = F)
  
  test_stat = sigma1_test_stat(X1, X2, d1, d2)
  n1 = nrow(X1)
  n2 = nrow(X2)
  
  boot_stats = vector()
  
  for (j in 1:B) {
    
    print(j)
    
    X1t <- X1[sample(1:n1, size = n1, replace = T),]
    X2t <- rbind(X1, X2)[sample(1:(n1+n2), size = n2, replace = T),]
    boot_stats[j] = sigma1_test_stat(X1t, X2t, d1, d2)
    
  }
  
  p_value <- mean(boot_stats < test_stat)
  
  return(list(test_stat = test_stat, p_value = p_value, boot_stats = boot_stats))
  
}

CD = function(X1, X2, d1, d2, epsilon, B) {
  
  p <- ncol(X1)
  
  sigma_x1 <- cov(X1)
  sigma_x2 <- cov(X2)
  
  OUT <- est_Vx_Vs(X1, X2, d1, d2)
  singular_vals <- rev(sing_vals(OUT$V1, OUT$V2))
  
  L <- list()
  L$CD <- sum(singular_vals < 1 - epsilon) + max(d1-d2, 0)
  
  test = boot_test(X1, X2, d1, d2, B)
  
  L$test_stat = test$test_stat
  L$p_value = test$p_value
  L$singular_vals <- singular_vals
  
  return(L)
  
}
```

Simulation 1. First generate data under the assumption that C(X1) c C(X2).

```{r}
generate_fake_data = function(p, n1, n2, d1, d2, sd1, sd2) {
  
  S2 <- qr.Q(qr(matrix(rnorm(n = p * d2), nrow = p)))
  S1 <- S2[, 1:d1]
  
  z1 <- matrix(rnorm(d1 * n1), nrow = d1)
  z2 <- matrix(rnorm(d2 * n2), nrow = d2)
  
  e1 <- matrix(rnorm(p * n1, sd = sd1), nrow = p)
  e2 <- matrix(rnorm(p * n2, sd = sd2), nrow = p)
  
  X1 <- t(S1 %*% z1 + e1)
  X2 <- t(S2 %*% z2 + e2)
  
  return(list(X1 = X1, X2 = X2))
  
}

set.seed(1)
d1 <- 6
d2 <- 8
sd1 <- 0.5
sd2 <- 0.5
L <- generate_fake_data(20, 100, 100, d1, d2, sd1, sd2)

OUT <- CD(L$X1, L$X2, d1, d2, 0.1, 1000)

OUT
```

(Simulation 2.) Next, under the assumption of unique directions in X1 orthogonal to C(X2).

```{r}
generate_fake_data_ortho = function(p, n1, n2, d1, d2, d12, sd1, sd2) {
  
  ovlp <- d1 - d12
  
  S2 <- qr.Q(qr(matrix(rnorm(n = p * (d1+d2)), nrow = p)))
  S1 <- S2[, 1:d1]
  S2 <- S2[, (d1-ovlp+1):(d1-ovlp+d2)]
  
  z1 <- matrix(rnorm(d1 * n1), nrow = d1)
  z2 <- matrix(rnorm(d2 * n2), nrow = d2)
  
  e1 <- matrix(rnorm(p * n1, sd = sd1), nrow = p)
  e2 <- matrix(rnorm(p * n2, sd = sd2), nrow = p)
  
  X1 <- t(S1 %*% z1 + e1)
  X2 <- t(S2 %*% z2 + e2)
  
  return(list(X1 = X1, X2 = X2))
  
}

set.seed(1)
d1 <- 6
d2 <- 8
d12 <- 6
sd1 <- 0.5
sd2 <- 0.5
L <- generate_fake_data_ortho(20, 100, 100, d1, d2, d12, sd1, sd2)

OUT <- CD(L$X1, L$X2, d1, d2, 0.1, 1000)

OUT
```


Validity/Conservativism plots. Simulation 1 of p-value (Hypothesis Test).

```{r}
set.seed(1)

iterations = 100
B = 1000
p_values = vector()

generate_fake_data = function(p, n1, n2, d1, d2, sd1, sd2) {
  
  S2 <- qr.Q(qr(matrix(rnorm(n = p * d2), nrow = p)))
  S1 <- S2[, 1:d1]
  
  z1 <- matrix(rnorm(d1 * n1), nrow = d1)
  z2 <- matrix(rnorm(d2 * n2), nrow = d2)
  
  e1 <- matrix(rnorm(p * n1, sd = sd1), nrow = p)
  e2 <- matrix(rnorm(p * n2, sd = sd2), nrow = p)
  
  X1 <- t(S1 %*% z1 + e1)
  X2 <- t(S2 %*% z2 + e2)
  
  return(list(X1, X2))
  
}

for (i in 1:iterations) {
  
  print(i)
  
  n1 = 100
  n2 = 100
  d1 = 10
  d2 = 20
  
  original_data = generate_fake_data(30, 100, 100, 10, 20, 0.5, 0.5)
  X1 = original_data[[1]]
  X2 = original_data[[2]]
  true_stat = sigma1_test_stat(X1, X2, d1, d2)
  
  boot_stats = vector()
  
  for (j in 1:B) {
    
    X1t <- X1[sample(1:n1, size = n1, replace = T),]
    X2t <- rbind(X1, X2)[sample(1:(n1+n2), size = n2, replace = T),]
    boot_stats[j] = sigma1_test_stat(X1t, X2t, d1, d2)
    
  }
  
  p_values[i] <- sum(boot_stats < true_stat) / B
  
}

p_values

summary(p_values)

hist(p_values)

d = data.frame(alpha = seq(0, 1, 0.005),
               cumulatives = sapply(seq(0, 1, 0.005), function(x) sum(p_values < x)/iterations))

g1 <- ggplot(data = d) +
  geom_point(aes(x = alpha, y = cumulatives)) +
  labs(x = "alpha", y = "Observed Type I Error Rate",
       title = "") +
  geom_abline(intercept = 0, slope = 1) +
  theme_classic()

#plot(seq(0, 1, 0.005), sapply(seq(0, 1, 0.005), function(x) sum(p_values < x)/iterations),
#     xlab = "alpha", ylab = "Observed Type I Error Rate",
#     main = "Simulated Data Under H0: Conservative Test")
#abline(a = 0, b = 1)
```